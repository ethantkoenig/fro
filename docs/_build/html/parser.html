

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Fro 101 &mdash; Fro 2.0.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Fro 2.0.0 documentation" href="index.html"/>
        <link rel="next" title="Fro Interface" href="api.html"/>
        <link rel="prev" title="Introduction to Fro" href="intro.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Fro
          

          
          </a>

          
            
            
              <div class="version">
                2.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction to Fro</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Fro 101</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#parsing-via-chomping">Parsing via chomping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#combining-parsers-composition">Combining parsers: composition</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parser-significance">Parser significance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chunks">Chunks</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Fro Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="report_bugs.html">Reporting Bugs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Fro</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Fro 101</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/parser.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fro-101">
<h1>Fro 101<a class="headerlink" href="#fro-101" title="Permalink to this headline">¶</a></h1>
<p><code class="docutils literal"><span class="pre">Parser</span></code> objects are the workhorses of the fro module, providing all of the module&#8217;s core parsing functionality.
However, there are a few subtleties to how they operate, which will be discussed in this section.</p>
<div class="section" id="parsing-via-chomping">
<h2>Parsing via chomping<a class="headerlink" href="#parsing-via-chomping" title="Permalink to this headline">¶</a></h2>
<p>Conceptually, when a <code class="docutils literal"><span class="pre">Parser</span></code> object parses a string, it first attempts to &#8220;consume&#8221; an initial portion of the string,
and from it produce a value. We will refer to this process (consuming an initial portion of the string and producing a
value) as the parser &#8220;chomping&#8221; the string. The terminology evokes a useful mental image, and may also be part of an
elaborate scheme to make a <a class="reference external" href="https://en.wikipedia.org/wiki/Noam_Chomsky">Noam Chomsky</a> pun.</p>
<p>If the parser is not successful in chomping the string, then it fails to parse it. Otherwise, the parser is successful
in <em>parsing</em> the string if (and only if) it consumed the <em>entire</em> string during chomping. This conceptual model will be
useful for understanding what happens when <code class="docutils literal"><span class="pre">Parser</span></code> objects are combined into new parsers.</p>
<p>As an example, <code class="docutils literal"><span class="pre">fro.intp</span></code> is a parser which consumes non-empty sequences of digits (and other things
you might expect to see in an integer, like a leading minus sign) and produces the corresponding <code class="docutils literal"><span class="pre">int</span></code> values. When parsing the string <code class="docutils literal"><span class="pre">&quot;2358&quot;</span></code>
it will consume the initial portion <code class="docutils literal"><span class="pre">&quot;2358&quot;</span></code> (which happens to be the entire string), and from it produces
the <code class="docutils literal"><span class="pre">int</span></code> value <code class="docutils literal"><span class="pre">2358</span></code>. Since the parser consumes the entire string during chomping, the parse is successful.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;2358&quot;</span><span class="p">)</span>  <span class="c1"># chomps &quot;2358&quot; producing 2358, a successful parse!</span>
</pre></div>
</div>
<p>When parsing the string <code class="docutils literal"><span class="pre">&quot;123abc&quot;</span></code>, it will consume the initial portion <code class="docutils literal"><span class="pre">&quot;123&quot;</span></code>, producing the <code class="docutils literal"><span class="pre">int</span></code> value
<code class="docutils literal"><span class="pre">123</span></code>. However, the parse will be unsuccessful since the remaining <code class="docutils literal"><span class="pre">&quot;abc&quot;</span></code> was not consumed.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;123abc&quot;</span><span class="p">)</span>  <span class="c1"># chomps &quot;123&quot; producing 123, an unsuccessful parse</span>
</pre></div>
</div>
<p>Finally, when parsing the string <code class="docutils literal"><span class="pre">&quot;abc123&quot;</span></code>, it will not be able to consume any part of the string, since there is no
initial portion that contains only digits. Since <code class="docutils literal"><span class="pre">fro.intp</span></code> only consumes <em>non-empty</em> sequences of digits, it cannot
consume an empty initial portion (which parsers are in general allowed to do).:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;abc123&quot;</span><span class="p">)</span>  <span class="c1"># cannot chomp anything, an unsuccessful parse</span>
</pre></div>
</div>
</div>
<div class="section" id="combining-parsers-composition">
<h2>Combining parsers: composition<a class="headerlink" href="#combining-parsers-composition" title="Permalink to this headline">¶</a></h2>
<p>With this model in place, it is much easier to make sense of what happens when you combine parsers together.
As a case study, let&#8217;s consider parser composition. Given two parsers <code class="docutils literal"><span class="pre">p1</span></code> and <code class="docutils literal"><span class="pre">p2</span></code>, the composition of <code class="docutils literal"><span class="pre">p1</span></code> and
<code class="docutils literal"><span class="pre">p2</span></code> is a new parser, separate from but dependent on <code class="docutils literal"><span class="pre">p1</span></code> and <code class="docutils literal"><span class="pre">p2</span></code>. When chomping a string, it first has <code class="docutils literal"><span class="pre">p1</span></code>
attempt to chomp. If <code class="docutils literal"><span class="pre">p1</span></code> successfully chomps, then <code class="docutils literal"><span class="pre">p2</span></code> chomps on the remaining, unconsumed portion of the string.
If either <code class="docutils literal"><span class="pre">p1</span></code> or <code class="docutils literal"><span class="pre">p2</span></code> is unable to chomp, the composition does not successfully chomp. If both <code class="docutils literal"><span class="pre">p1</span></code> and <code class="docutils literal"><span class="pre">p2</span></code>
are able to chomp and produce values <code class="docutils literal"><span class="pre">v1</span></code> and <code class="docutils literal"><span class="pre">v2</span></code> respectively, then the composition consumes both of the portions
that <code class="docutils literal"><span class="pre">p1</span></code> and <code class="docutils literal"><span class="pre">p2</span></code> consumed and produces the tuple <code class="docutils literal"><span class="pre">(v1,</span> <span class="pre">v2)</span></code>.</p>
<p>As an example, consider the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a_to_z</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">rgx</span><span class="p">(</span><span class="s2">r&quot;[a-z]*&quot;</span><span class="p">)</span>  <span class="c1"># consumes, and then produces, strings that match regex</span>
<span class="n">composition_parser</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">az_parser</span><span class="p">])</span>  <span class="c1"># composition of fro.intp and a_to_z</span>
<span class="n">composition_parser</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;2357primes&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">composition_parser</span></code> tries to chomp <code class="docutils literal"><span class="pre">&quot;2357primes&quot;</span></code>, first <code class="docutils literal"><span class="pre">fro.intp</span></code> will consume <code class="docutils literal"><span class="pre">&quot;2357&quot;</span></code> (of off
<code class="docutils literal"><span class="pre">&quot;2357primes&quot;</span></code>) and produce <code class="docutils literal"><span class="pre">2357</span></code>, then <code class="docutils literal"><span class="pre">az_parser</span></code> will consume <code class="docutils literal"><span class="pre">&quot;primes&quot;</span></code> (of off <code class="docutils literal"><span class="pre">&quot;primes&quot;</span></code>, which is
what remains after <code class="docutils literal"><span class="pre">fro.intp</span></code>&#8216;s chomp) and produces <code class="docutils literal"><span class="pre">&quot;primes&quot;</span></code>. Therefore, <code class="docutils literal"><span class="pre">composition_parser</span></code>
consumes <code class="docutils literal"><span class="pre">&quot;2357primes&quot;</span></code> and produces the tuple <code class="docutils literal"><span class="pre">(2357,</span> <span class="pre">&quot;primes&quot;)</span></code>. Since <code class="docutils literal"><span class="pre">composition_parser</span></code> chomps the entire
string, it parses successfully.</p>
<p>As another example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">twoints_parser</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">])</span>
<span class="n">twoints_parser</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;149&quot;</span><span class="p">)</span>  <span class="c1"># what will happen??</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">twoints_parser</span></code> tries to chomp <code class="docutils literal"><span class="pre">&quot;149&quot;</span></code>, the first <code class="docutils literal"><span class="pre">fro.intp</span></code> will consume <code class="docutils literal"><span class="pre">&quot;149&quot;</span></code> and produce <code class="docutils literal"><span class="pre">149</span></code>.
However, there will nothing left for the second <code class="docutils literal"><span class="pre">fro.intp</span></code> to consume, so it will not successfully chomp anything.
Since the second <code class="docutils literal"><span class="pre">fro.intp</span></code> cannot chomp, the composition fails to chomp, and thus fails to parse.</p>
<p>This example highlights an important property of fro parsers: parsers chomp myopically. If the first <code class="docutils literal"><span class="pre">fro.intp</span></code> in the
above example had known that it was followed by another <code class="docutils literal"><span class="pre">fro.intp</span></code>, it perhaps could have only chomped the first two digits,
leaving the <code class="docutils literal"><span class="pre">&quot;9&quot;</span></code> for the second <code class="docutils literal"><span class="pre">fro.intp</span></code>, and the composition could have produced the tuple <code class="docutils literal"><span class="pre">(14,</span> <span class="pre">9)</span></code>. However,
<code class="docutils literal"><span class="pre">fro.intp</span></code> is based on the regular expression <code class="docutils literal"><span class="pre">[0-9]+</span></code>, which matches as many digits as possible, so it consumes
as many digits as possible while chomping.</p>
<p>Finally, you can compose more than two parsers together. Consider the following:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">composition</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">fro</span><span class="o">.</span><span class="n">rgx</span><span class="p">(</span><span class="s2">r&quot;@&quot;</span><span class="p">),</span> <span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">fro</span><span class="o">.</span><span class="n">rgx</span><span class="p">(</span><span class="s2">r&quot;@&quot;</span><span class="p">),</span> <span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">])</span>
<span class="n">composition</span><span class="o">.</span><span class="n">parse_str</span><span class="p">(</span><span class="s2">&quot;123@45@6&quot;</span><span class="p">)</span>  <span class="c1"># returns the tuple (123, &quot;@&quot;, 45, &quot;@&quot;, 6)</span>
</pre></div>
</div>
<p>When <code class="docutils literal"><span class="pre">composition</span></code> attempts to chomp <code class="docutils literal"><span class="pre">&quot;123&#64;45&#64;6&quot;</span></code>, the first <code class="docutils literal"><span class="pre">fro.intp</span></code> consumes <code class="docutils literal"><span class="pre">&quot;123&quot;</span></code> and produces <code class="docutils literal"><span class="pre">123</span></code>.
Then, the remaining, unconsumed <code class="docutils literal"><span class="pre">&quot;&#64;45&#64;6&quot;</span></code> is given to the first <code class="docutils literal"><span class="pre">r&quot;&#64;&quot;</span></code> parser to chomp, which consumes and produces
<code class="docutils literal"><span class="pre">&quot;&#64;&quot;</span></code>. After this, the remaining, unconsumed <code class="docutils literal"><span class="pre">&quot;45&#64;6&quot;</span></code> is given to the second <code class="docutils literal"><span class="pre">fro.intp</span></code>, so it continues for each
of the composition&#8217;s children parsers. The children parsers produces the values <code class="docutils literal"><span class="pre">123</span></code>, <code class="docutils literal"><span class="pre">&quot;&#64;&quot;</span></code>, <code class="docutils literal"><span class="pre">45</span></code>, <code class="docutils literal"><span class="pre">&quot;&#64;&quot;</span></code>, and
<code class="docutils literal"><span class="pre">6</span></code> respectively, so the composition produces the tuple <code class="docutils literal"><span class="pre">(123,</span> <span class="pre">&quot;&#64;&quot;,</span> <span class="pre">45,</span> <span class="pre">&quot;&#64;&quot;,</span> <span class="pre">6)</span></code>.</p>
</div>
<div class="section" id="parser-significance">
<h2>Parser significance<a class="headerlink" href="#parser-significance" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, when we compose multiple parsers together, some of the values produced by the children parsers are not important. In the above
example, we might only care about the three int values, and not about the delimiting <code class="docutils literal"><span class="pre">&quot;&#64;&quot;</span></code> values.
To exclude some produced values from the resulting tuple of a composition, we can mark some of it&#8217;s children as
insignificant:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">composition</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="o">-</span><span class="n">fro</span><span class="o">.</span><span class="n">rgx</span><span class="p">(</span><span class="s2">r&quot;@&quot;</span><span class="p">),</span> <span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="o">-</span><span class="n">fro</span><span class="o">.</span><span class="n">rgx</span><span class="p">(</span><span class="s2">r&quot;@&quot;</span><span class="p">),</span> <span class="n">fro</span><span class="o">.</span><span class="n">intp</span><span class="p">])</span>
<span class="n">composition</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">&quot;123@45@6&quot;</span><span class="p">)</span>  <span class="c1"># returns the tuple (123, 45, 6)</span>
</pre></div>
</div>
<p>Here, the <code class="docutils literal"><span class="pre">-fro.rgx(r&quot;&#64;&quot;)</span></code> evaluates to an insignificant version of the parser <code class="docutils literal"><span class="pre">fro.rgx(r&quot;&#64;&quot;)</span></code>; for more on the syntax of marking parsers as
significant or insignificant, see <a class="reference internal" href="api.html"><span class="doc">Fro Interface</span></a>. What is important to notice is that the <code class="docutils literal"><span class="pre">&quot;&#64;&quot;</span></code> value are not present in the tuple
value produced by <code class="docutils literal"><span class="pre">composition</span></code>.</p>
<p>Parsers are significant by default. If a parser is insignificant, that only means that the values it produces will be ignored when it appears inside a
composition. An insignificant parser will still produce a value if you directly call <code class="docutils literal"><span class="pre">parse(..)</span></code> on it, or if it
appears in something other than a composition.</p>
</div>
<div class="section" id="chunks">
<h2>Chunks<a class="headerlink" href="#chunks" title="Permalink to this headline">¶</a></h2>
<p>When parsing a large text file, it&#8217;s preferable to not have to read the entire file into memory.
Instead, iterating through the file one piece at a time leads to much better use of memory.</p>
<p>To support efficient use of memory, Fro breaks the text it is parsing into &#8220;chunks&#8221;. When a parser
chomps, it chomps on one chunk at a time, and only moves to the next chunk once it has completely
consumed the current one. Regular expression parsers, which are used to construct practically
every other type of parser, can only operate inside a single chunk.</p>
<p>Let&#8217;s consider an example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">composition</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="s2">r&quot;abc&quot;</span><span class="p">,</span> <span class="s2">r&quot;def&quot;</span><span class="p">])</span>

<span class="c1"># the first argument to parse(..) is a collection of chunks to parse</span>
<span class="n">composition</span><span class="o">.</span><span class="n">parse</span><span class="p">([</span><span class="s2">&quot;abcd&quot;</span><span class="p">,</span> <span class="s2">&quot;ef&quot;</span><span class="p">])</span>
<span class="c1"># This parse will fail. The first regex parser will chomp &quot;abc&quot; off of the first</span>
<span class="c1"># chunk &quot;abcd&quot;, leaving &quot;d&quot; behind. The second regex parser will try to chomp off</span>
<span class="c1"># the remainder of the first chunk, but fail. Since regular expressions cannot</span>
<span class="c1"># &quot;wrap&quot; around to the next chunk if the current chunk is not fully consumed, it</span>
<span class="c1"># does not matter that &quot;ef&quot; are waiting for us in the second chunk.</span>
</pre></div>
</div>
<p>By default, the lines of a text file serve as the chunks of a file. If you want to
split your input text into chunks some other way, you can pass any iterable collection of
strings into a parser&#8217;s <code class="docutils literal"><span class="pre">parse(..)</span></code> method, and the parser will treat each element
as an individual chunk.</p>
<p>Since a parser can only move onto the next chunk after it has completely consumed the current chunk,
it is important that a parser can unambiguously decide how to parse a chunk before moving onto the
next one. To make this more concrete, let&#8217;s consider another example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">a_then_b</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="s2">r&quot;a&quot;</span><span class="p">,</span> <span class="s2">r&quot;b&quot;</span><span class="p">])</span>
<span class="n">a_then_c</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">comp</span><span class="p">([</span><span class="s2">r&quot;a&quot;</span><span class="p">,</span> <span class="s2">r&quot;c&quot;</span><span class="p">])</span>

<span class="c1"># fro.alt(..) constructs an alternation parser, see the docs for more info</span>
<span class="n">ab_or_ac</span> <span class="o">=</span> <span class="n">fro</span><span class="o">.</span><span class="n">alt</span><span class="p">([</span><span class="n">a_then_b</span><span class="p">,</span> <span class="n">a_then_c</span><span class="p">])</span>

<span class="n">ab_or_ac</span><span class="o">.</span><span class="n">parse</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
<span class="c1"># This parse will fail. The ab_or_ac parser will first try to parse with a_then_b.</span>
<span class="c1"># The r&quot;a&quot; regex will chomp the entire first chunk (&quot;a&quot;). When the r&quot;b&quot; regex tries</span>
<span class="c1"># to chomp the second chunk (&quot;c&quot;), it will fail. At this point, the parser has</span>
<span class="c1"># already advanced to the second chunk, so it has no way of returning to the first</span>
<span class="c1"># chunk to try chomping with a_then_c, so it fails immediately.</span>
</pre></div>
</div>
<p>In the above example, the parser can&#8217;t know how to interpret the <code class="docutils literal"><span class="pre">&quot;a&quot;</span></code> in the first chunk without
looking at the second chunk. That is, the parser doesn&#8217;t know if the <code class="docutils literal"><span class="pre">&quot;a&quot;</span></code> is part of something that
<code class="docutils literal"><span class="pre">a_then_b</span></code> will recognize, or part of something that <code class="docutils literal"><span class="pre">a_then_c</span></code> will recognize. In this case,
it blindly chooses <code class="docutils literal"><span class="pre">a_then_b</span></code>, and fails.</p>
<p>What about all of the above examples where we just called <code class="docutils literal"><span class="pre">parser.parse_str</span></code>,
and didn&#8217;t worry about chunks? When called with the <code class="docutils literal"><span class="pre">parse_str</span></code> method, a parser
treats the entire string as a single chunk.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api.html" class="btn btn-neutral float-right" title="Fro Interface" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="intro.html" class="btn btn-neutral" title="Introduction to Fro" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Ethan Koenig.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.0.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>